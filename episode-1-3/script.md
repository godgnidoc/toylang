<h1>词法分析 - 第三节</h1>

> Version 1.0.0 by GodGnidoc; Jul. 29, 2024

# 000. Surface

小伙伴们大家好，上期视频，我们已经完成了正则表达式的解析。

# 001. Introduce

本期视频我们来学习如何构建一种词法分析器。它可以加载词法规则，将输入字符序列解析为单词序列。

词法规则需要被转换为<u>确定有穷状态机</u>才能被<u>词法分析器</u>加载，第一小节我们先来学习确定有穷状态机的结构和工作原理。

有了对确定有穷状态机的基本认识，第二小节里，我们就可以设计出词法分析器的接口和相关数据结构。并编写一些必要的周边设施备用。

第三小节我们学习一种高效、优雅，但没有名字的算法，将一条正则表达式转换为等价的确定有穷状态机。

我们还会讨论如何将众多匹配不同单词的正则表达式拼接成一条匹配全部单词的全文正则表达式。

我们希望只执行一次转换算法，从全文正则表达式得到正确的确定有穷状态机作为词法分析器的输入。

这样就不用学习确定有穷状态机合并算法了。。。咳咳

在最后一小节里，我们会补完词法分析器的主要逻辑代码，完成各模块的拼装。最后再编写一些测试用例来验证我们的工作。

# 002. principle

首先，确定有穷状态机是图灵机的一种简化模型。它拥有一个<u>初始状态</u>、若干个<u>中间状态和接受状态</u>。

每次工作，状态机会回到初始状态，然后逐个读取输入字符尝试跳转状态。每个状态上都记录了一组转移规则用于根据输入字符选择跳转目标。

若转移规则不接受当前输入字符，分析结束。

此时若当前状态为接受状态，则从起始状态到当前状态的过程中输入的全部字符构成了一个单词，接受状态上记录了这个单词的ID。

否则状态机会言辞激烈的告诉我们它遭遇了一个词法错误。



# 2. 实现有穷状态机

## 2.1. 单词数据结构

首先我们要设计有穷状态机的输出结构，一个单词由单词ID、单词文本和它的位置构成。

其中单词ID的作用是在语法级的问题中快速鉴别一个单词的身份和作用。比如运算符和关键字，在语法分析阶段我们并不关心这些单词如何书写，单词ID的存在极大简化了语法分析算法的实现。

而部分单词，他的书写内容在词法分析阶段是有意义的，比如字面值和标识符。一些比较高级的语法分析器也可以在语法分析阶段利用单词的文本内容变换上下文以提供更复杂的语法支持。

最后，单词的位置信息可以用于生成精确的报错文本或发送给编辑器用于准确提供高亮支持。

## 2.2. 词法规则数据结构

接下来，有穷状态机由状态跳转图驱动，我们要设计一个数据结构用于装载状态跳转图，以便构造有穷状态机时加载使用。

状态跳转图几乎等价于词法规则，我们要携带当前词法规则所定义的单词名称与ID的对应关系。这里直接使用一个线性表来存储单词名称，每个名称的下标加一刚好等于此名称所表示的单词的ID。

接下来，我们还要保存一个上下文名称与ID的对应表，结构与单词表类似，只不过ID从0开始编号，也就是上下文名称的下标直接等于上下文ID。

上下文的用途是动态切换整篇词法规则中生效的部分，以此可以在不同的语境中切换相同或相似词法所产生的单词ID，可以极大的扩展语言的可写性。

不过Up还没想好如何自然地把上下文切换的指令融合到文法规则中，又不想像 `BISON` 一样在文法中穿插 C++ 代码，所以这部分功能尚未开发，此字段仅用于扩展性预留。

接下来，是状态定义表，依然是一张线性表，每个元素的下标即当前状态的ID。每个状态都由一个结构体描述，其中包含一个可选的 `accept` 字段，用于表示当前状态可以接受的单词ID，若省略则表示当前状态不可接受任何单词。另一个字段 `transfer` 是一张输入字符与可行跳转的节点ID的对照表，`transfer`表中未提及的字符是当前状态不能接受的输入。

至此，我们已经得到了状态跳转图的数据结构定义。状态跳转图与词法规则几乎等价，我们将数据结构用一个名为 `Lexicon` 的类包裹起来，添加一些便于操作的接口函数。

## 2.3. 词法分算法

接下来，我们来设计一个名为 `Scanner` 的类用于抽象词法分析器，它的作用是加载词法规则，利用词法规则内的状态跳转图将输入串处理成一个个的单词。

`Scanner` 类需要一些属性来保存当前状态，包括当前上下文，当前输入在全文的位置，以及当前正在使用的词法规则和正在分析的上下文。

我们为 `Scanner` 添加一些基本接口用于准备词法分析所需的环境，之后，我们来设计 `NextToken` 接口用于从当前输入开始尝试分析一个单词或报告一个词法错误。

首先，我们要检查并确保词法分析所需的基本环境已经就绪。然后我们构造一个临时单词对象用于保存本次分析的结果。

若当前输入已经耗尽，我们直接将刚构造的单词用作返回值，因为它此刻的配置刚好可以表示输入的结束。

接下来，我们从状态跳转图的第一个状态开始，将当前上下文用作虚拟的输入字符来找到真正用于开始分析单词的第一个状态。这个步骤需要状态跳转图的构建算法配合，将上下文用作第一个状态的输入来填写跳转规则，指向一个词法规则子集用于仅分析在某状态下才启用的单词。

接下来，我们用一个循环来驱动状态机不断输入字符，跳转状态。直到不能继续输入字符时接受一个单词或报告一个词法错误。

首先，将当前输入字符提取出来，然后依据输入字符查找当前状态是否存在对应的跳转规则。

若存在，则跳转状态，在输入下一个字符前，将当前字符计入正在分析的单词的书写范围，并合理偏移当前位置的跟踪。

若当前输入没有对应的跳转规则，则检查当前状态是否能够接受一个单词。若能，则依据接受参数修正单词ID后直接跳出循环。

若当前状态不能接受单词，则应该报告一个词法错误。我们将当前单词的ID修改为一个词法错误标志，但是此时不能立刻退出循环，我们要复用循环体下半部分的代码将当前输入字符吸收到这个词法错误记号中，然后再利用循环条件退出循环。

考虑一种场景，假设导致词法错误的当前输入字符是本次词法分析遭遇第一个字符，如果我们不将它吸收到错误记号中消费掉的话，下一次进入词法分析函数，第一眼看见的将还是它。

我们会因此陷入死循环而不得不在遭遇第一个词法错误时停止分析，而不是带着错误继续完成全文分析，尽可能报告更多的潜在词法错误。这会降低我们编译器的好评率。

此外，使用 `state = 0` 作为循环继续的条件安全吗？当然，因为 0 状态是我们手动创建的一个假状态，用于输入当前上下文选择对应词法规则集所表示的状态跳转图中的首状态。从这样的首状态出发分析单词，无论怎么绕，都不可能绕回到一个以上下文为输入的状态上。故安全。

以上，当循环结束时，无论处于何种原因，我们的单词变量中已经存储了我们想返回给调用者分析结果。

至此，我们已经完成了词法分析器中有穷状态机的实现，接下来，我们来研究如何从正则表达式生成与之等价的状态跳转图。

# 3. 状态跳转图生成

## 3.1. 词法构造器数据结构

我们使用 `Lexicon` 名下的类中类 `Lexicon::Builder` 向用户提供词法规则也就是状态跳转图的构造功能。

通过调用 `Lexicon::Builder` 类的 `DefineToken` 接口可以定义一个单词，用户需要提供单词名与对应的正则表达式。

可选地，用户还可以为此定义指定一个上下文集合，表示当前单词仅在这些上下文中生效。若省略此参数，则表示当前单词应当在任意上下文都生效。

用户应当连续多次调用 `DefineToken` 接口，将全部单词定义添加到构建器中，最后调用 `Build` 接口生成状态跳转图。

在 `Build` 接口要求 `Lexicon::Builder` 生成状态跳转图之前，`Lexicon::Builder` 类在其内部的构造上下文中维护了一条超长的正则表达式。

它由全部单词的正则表达式通过联合语法拼接而成，用于最终生成状态跳转图的主体。

`global_patterns_` 登记了添加定义时未指定上下文的单词的正则表达式入口。`firstpos_ctx_map_` 用于记录每一个单词的正则表达式的 `firstpos` 与上下文的映射关系。这两个字段共同用于生成以上下文为输入的虚拟状态。

正如前文所述，我们生成的状态跳转图中的0号状态是一个虚拟状态。它的输入是当前上下文ID而不是字符。

它的作用是引导词法分析器进入一个与指定上下文匹配的状态子集后再开始工作。这个子集只识别在当前上下文才生效的词法规则。

最后，`impl_` 字段用于存储正在构建的词法规则的实际数据结构，用于登记单词名表和上下文名表。

## 3.2. 正则表达式特征计算

上述便是状态跳转图生成算法所需的数据结构了。在开始讲解 `DefineToken` 和 `Build` 接口的具体行为之前，让我们先来了解一些前置概念。

上期视频中我们学习了如何从正则表达式产生语法分析树。仔细观察发现，它的叶子节点一定是用于匹配单个字符的 `Char` 节点或 `Range` 节点。同时，这两种节点也一定是叶子节点。

实际上，当我们尝试检查一个字符串是否匹配给定正则表达式时，一定是在不断选取一些叶子节点与当前输入字符做比对。

基于当前已成功匹配的子串，能够挑选参与下一次匹配的叶子节点集合是确定的。这样的集合就是状态跳转图上的一个状态，当前已成功匹配的子串正是从初始状态抵达当前状态的路径之一。

要顺利找到全部状态并在状态间建立正确的跳转关系，我们需要先计算一些蕴藏在正则表达式结构中的辅助信息。

- `Nullable` 是一个布尔值，表示当前表达式是否可空，也就是是否可以跳过
- `FirstPos` 是表达式中可以参与第一次匹配的叶子节点的集合
- `LastPos` 是表达式中可能参与最后一次匹配的叶子节点的集合
- `FollowPos` 要为每个叶子节点分别计算，它表示在当前叶子节点匹配成功后，接下来可以参与匹配的叶子节点的集合

上述四种特征针对不同语法结构都有不同的计算方法，接下来我们将针对每一种语法结构展开讲解对应算法。

为了方便各节点的特征算法互相调用，我们在节点基类上声明 4 个虚函数

- `GetNullable` 用于计算当前表达式是否可空、
- `GetFirstpos` 用于获取当前表达式的 `Firstpos` 集合、
- `GetLastpos` 用于获取当前表达式的 `Lastpos` 集合、
- 以及 `CalcFollowpos` 用于为当前表达式上的每个叶子节点计算 `followpos` 集合。

此外，我们将 `CharNode` 和 `RangeNode` 归纳为叶子节点，编写一个 LeafNode 作为二者的共同基类来提供一些公共抽象。

首先，每个叶子节点都有自己的 `FollowPos` 集合，为了简化后续代码的编写，我们在 `LeafNode` 抽象类上定义一个 `followpos_` 变量用于存储计算结果。

其次，每个叶子节点都能参与字符匹配，我们定义一个纯虚函数 `Match` 用于检查某个输入字符与当前节点是否匹配。

最后，叶子节点的 `FollowPos` 都是由树中的非叶子节点负责计算的，它们自身的 `CalcFollowpos` 函数都是没有实际行为的。我们在 `LeafNode` 类这一层集中重写一个空的实现，并标记为 `final` 表示其子类都不必再重写此接口。

有了这些准备，我们就可以开始为每一种语法结构设计特征计算算法了。

首先， `CharNode` 被用于匹配一个字符，它不可能为空。它的 `FirstPos` 和 `LastPos` 当然都只包含它自己。

`CharNode` 的 `Mach` 接口只需要简单的检查当前输入字符是否与预期字符相等即可。

`RangeNode` 同属用于匹配一个字符的叶子节点，它也无法被跳过，不能为空。`FirstPos` 和 `LastPos` 集合也都只包含它自己。

`RangeNode` 节点的 `Match` 算法要稍微复杂一点，它根据当前范围的方向性检查输入字符与登记字符集的关系。若当前范围为消极范围，则输入字符不应该属于登记字符集。否则，当前范围为积极范围，则输入字符应当属于登记字符集。

`ConcatNode` 表示左右子式要按顺序先后匹配，若左右子式都可以为空，则 `ConcatNode` 可以为空。`ConcatNode` 的 `FirstPos` 集合必然包含其左子式的 `FirstPos` 集合。

特别地，若 `ConcatNode` 节点的左子式可以为空，则它的 `FirstPos` 集合还应当包含其右子式的 `FirstPos`。

`ConcatNode` 节点的 `LastPos` 集计算规则类似，它必然包含右子式的 `Lastpos` 集合，若右子式可以为空，左子式的 `LastPos` 集合也能当被包含其中。

在 `CalcFollowpos` 算法中，`ConcatNode` 节点要将其右子式的 `FirstPos` 添加到其左子式的 `LastPos` 中的每个叶子节点的 `Followpos` 中。这表示从左子式的任意位置结束匹配，都要全面进入右子式的开始匹配工作。

要记得递归调用左右子式的 `CalcFollowpos`  接口，确保全面计算每一个子式的 `Followpos` 集合。

`UnionNode` 节点表示两个子式匹配其一即可，左右任一子式可以为空则 `UnionNode` 可以为空。它的 `Firstpos` 和 `Lastpos` 是它左右子式的 `Firstpos` 和 `Lastpos` 的并集。

`UnionNode` 并不干扰左右子式中 `Followpos` 的分布，只要分别递归调用 `CalcFollowpos` 接口把计算任务传递下去就好。

`KleenNode` 表示匹配一个子式0次或多次，嗯，它一定可空。它的 `Firstpos` 和 `Lastpos` 集合分别取用其子式的 `Firstpos` 和 `Lastpos` 即可。

`KleenNode` 接口同样要把 `FollowPos` 的计算任务传递下去。除此之外，`KleenNode` 的子式匹配成功之后，它还可以回过头来再来一次。我们把 `KleenNode` 的子式的 `FistPos` 添加到它自己的 `LastPos` 中的每个叶子节点的 `FollowPos` 中。

`PositiveNode` 表示匹配一个子式一次或多次。它是否为空取决于它的子式是否为空。它的 `FirstPos` 和 `LastPos` 也都与其子式的 `FirstPos` 和 `LastPos` 相等。

`PosotiveNode` 的 `CalcFollowpos` 算法与 `KleenNode` 节点的 `CalcFollowpos` 算法一致，除了需要传递 `FollowPos` 的计算任务以外，还要将其子式自身首尾相接，表示子式可以被反复匹配。

最后，`OptionalNode` 表示匹配一个子式0次或一次，它当然可以为空。它的 `FirstPos` 和 `LastPos` 都直接取自其子式的 `FirstPos` 和 `LastPos`。

`OptionalNode` 节点对 `FollowPos` 分布没有干扰，只要传递计算任务就好。

OK，至此，我们轻轻松松地完成了一个正则表达式的各项特征的计算。

依据现在的信息，我们已经能够从全文正则表达式的 `FirstPos` 构造 1 号状态，依据当前状态中的叶子节点的 `FollowPos` 集合顺藤摸瓜地找到针对每一个可接受的输入字符，下一个状态中参与字符匹配的叶子节点的集合。

## 3.3. 全文正则与接受节点

在真正开始构建一个状态跳转图之前，我们只剩最后一项准备工作需要做了。我们还需要一项辅助信息用于在某个状态上标注一个可接受的单词。

我们引入一种虚拟的正则表达式节点 `AcceptNode` 用于携带接受当前单词时所需的信息。

在定义一个单词时，我们为其创建专属的 `AcceptNode` 节点并添加到单词正则的 `LastPos` 集合中每个叶子节点的 `followpos_` 中。

这样，在构造状态跳转图时，`AcceptNode` 节点就会借机被混入当前单词被完整分析完毕后即将进入的一个或多个后继状态中。

我们可以在构造每个状态时，迭代被混入其中的全部 `AcceptNode`，筛选出其中优先级最高的节点用于登记当前状态的接受规则。

`DefineToken` 函数首先在单词表上创建一个单词，获得其ID。然后通过 `Accept` 操作为当前单词的正则表达式挂载接受节点。

若单词只能在一部分上下文生效，则记录单词正则表达式的 `FirstPos` 与生效上下文的 ID 集合的对应关系。否则将单词的正则表达式树根登记在 `global_patterns_` 表中。这部分工作用于支持以上下文ID为输入的0号状态和它的出度边的生成。

最后，将单词的正则表达式用作全文的第一个表达式，或将其与已经记录的全文表达式联合起来。

多次调用 `DefineToken` 接口即可获得一个用于生成状态跳转图的全文正则表达式。

## 3.4. 生成状态跳转图

终于来到了这一步，让我们来逐步实现 `Builder::Build` 函数，从正则表达式一步步生成一个状态跳转图吧。

构建算法维护一个 `pending_states` 列表用于登记尚未计算全部出度的状态。`state_pos_map` 表记录了每个状态下参与匹配的叶子节点，用于辅助出度计算。

首先，我们迭代 `global_patterns_` 中记录的在任意上下文都生效的正则表达式，将它们的 `firstpos` 中的全部叶子节点与全部已定义的上下文关联起来。

接下来，我们来生成 0 号状态。先为全文正则表达式调用 `CalcFollowpos` 函数计算每一个叶子节点的 `followpos` 集合。

接下来我们迭代每一个已定义的上下文，为这个上下文创建一个专属的首状态并添加到 `pending_states` 列表中等待处理。

从 0 号状态跳转到此首状态的所需的输入是当前上下文ID。我们为 0 号状态填写一条跳转规则。

接下来，我们迭代全文表达式的 `FirstPos` 集合中的全部叶子节点，将其中在当前上下文能够生效节点添加到当前首状态对应的叶子节点集合中。

完成全部上下文的迭代后，我们在 `pending_states` 列表中已经积攒了一系列待处理的状态。

接下来我们不断从 `pending_states` 列表中取出状态计算出度，直到 `pending_states` 列表耗尽为止。在这过程中若产生了全新的状态，则同样将其添加到 `pending_states` 列表中排队处理。

每次我们从 `pending_states` 列表中拿到一个当前状态，先找找其对应的叶子节点集中有没有接受节点。若当前状态中包含了多个接受节点，取其中单词ID最小的一个接受节点用于登记当前状态的接受规则。

接下来，我们为 `1` 到 `255` 范围内的每一个输入字符计算跳转状态。规则如下：

对当前输入字符 `ch` 迭代当前状态下每一个可以参与匹配的叶子节点，将其中能够成功匹配当前输入的叶子节点的 `followpos_` 集合收集起来取并集。

若这个结果集合为空，表示当前状态不能接受 `ch` 所代表的输入字符。

否则，这个集合就代表当前输入的后继状态。我们翻找一下 `state_pos_map` 表，看叶子节点集合相同的状态是否已经被创建过了。

若没有，则创建一个新状态，登记处理任务表，登记叶子节点集合对照表。

最后，拿到后继状态的id，填写出度边。

当循环退出时，表示处理任务队列已经耗尽。此时我们已经得到了一个完整的状态跳转图。我们把结果打包送走，就完成了全部分析任务。

## 4. 总结

至此，我们掌握了实现一个简单词法分析器及词法分析器生成器所需的基本知识。

下期视频我们来整理一下目前已有的代码，做一个简单可用的 demo 来验证我们的代码。

我们下期再见。