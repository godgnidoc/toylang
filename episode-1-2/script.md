<h1>词法分析 - 第二节</h1>

> Version 1.0.0 by GodGnidoc; Jul. 16, 2024

# 1. 补充

书接上回，我们已经学习了简单的正则表达式语法，本节视频，我们来编码完成一个正则表达式分析器。

但是不要急，在正式开始正则表达式分析器的编码前，我们还需要一小段补充内容。

上节内容对正则表达式语法的讲解中缺失了一个非常常用的重要语法。那就是特殊的字符类：任意字符。

任意字符是一个点，在常用的正则表达式实现中，它默认用于匹配一个除了回车以外的任意字符。但是在这里，为了简化实现，我们将其设计为用于匹配包括回车在内的任意字符。

接下来，上期视频有小伙伴觉得正则表达式语法得讲解缺少例子。话不多说，安排！

~~~js
/a(b*c|xy?)+d/
~~~

正如上期视频所说，正则表达式的含义体现的是字符串的结构。这个正则表达式所描述的结构可以这样阐述。

它要求，字符串应当以字母a开头，以字母d结尾。中间要包含至少一个子串。每个子串可以由任意个前缀b和一个结尾c构成；也可以由一个x和可选的一个y构成。

在字符串中缺失必要部分或在某个位置上存在未提及的字符都会导致匹配失败。

# 2. 环境介绍

好了，经过上述补充，我们终于可以开始正则表达式解析器的编码实现了。

这是我们的开发环境，在接下来的一段时间里，我们将在这里逐步开发我们的语法分析器乃至高级语言编译器。我们将本次视频将要开发的项目命名为 `toylang` 。

项目使用 `CMake` 驱动，include 和 src 文件夹分别用于存放头文件和源文件。build 文件夹被用于存放 `CMake` 缓冲和编译产物。`script`文件夹下存放了一些为提高工作效率准备的小脚本。

项目仓库在 `github` 上开源，欢迎大家克隆使用。

使用 Linux 系统的小伙伴可以通过 script 文件夹下的小脚本简化开发环境的使用。而使用 Windows 系统的小伙伴们可以将本仓库的源码导入自己熟悉的集成开发环境使用。

在终端键入 `source script/setup` 指令，即可将如下指令导入终端环境，方便使用。`setup` 脚本会修改当前终端的命令行提示符，将当前项目名和构建模式打印出来。

使用 `debug`和`release`指令可以通过修改环境变量来切换编译模式。

`build` 指令用于完成项目源码的扫描和目标程序的编译。

由于build路径被 setup 脚本收录为可执行程序的搜索路径，所以键入 `toylang` 即可运行我们编译好的可执行程序。

`clean`指令用于清理 `build` 路径下的全部内容，必要时慎重使用。

# 3. 存储结构设计

接下来我们开始设计正则表达式的存储结构。

我们目前所学的正则表达式语法可以被区分为七种类型。我们来定义一个包含七个枚举项的枚举类型，用来区分它们。

接下来，正则表达式的各种语法之间可以相互嵌套形成树状结构，我们需要一个顶级抽象来实现范型。我们称之为节点。节点间通过共享指针实现嵌套。

将可能被继承的类的析构函数标记为虚函数是个好习惯，避免使用基类指针销毁对象时析构流程残缺造成内存泄漏。

我们来声明一个纯虚函数用来返回当前节点的类型，用于在需要区别对待不同类型节点的场景动态判断节点类型。

有了这些准备，我们就可以开始逐一设计每个语法结构对应的数据结构了。首先是基本字符节点，无需多言，把它所表示的字符保存起来即可。不要忘了重载虚函数返回当前类型。

接下来是字符类语法，转义字符类、方括号字符类和点都属于字符类语法，我们将他们统一抽象为范围节点。

由于方括号字符类语法可以使用一个插入符表示接受范围取反。我们给范围节点定义一个方向枚举，消极表示记录了不接受的字符，积极表示记录了要接受的字符。使用集合来存储所有当前字符类提及的字符。

接下来是将左右子式连接起来的串语法。没错，实际上超过两个模式的串接是对串语法的连续使用，每个串语法只能连接两个子式。

联合语法同样需要分别记录左右两个子式。克林闭包、正闭包和可选都是后缀运算，它们只需要记录自己所修饰的子式即可。

# 4. 正则表达式解析

## 4.1. 算法概览

就这样，我们详细设计了七种不同的正则表达式语法的存储结构。接下来，我们来编写正则表达式的分析算法。

正则表达式自身的语法规则属于上下文无关文法，要处理它所需的正确工具正是本系列视频的最终目标：语法分析器。

但是在我们正式完成第一个能用的语法分析器之前，我们得先编写一个语法制导的简单翻译器来分析正则表达式。否则我们的工作就出现了循环依赖，无法顺利开展。

我们的算法思想大致如下：第一步，将输入中全部的字符和字符类分析成节点，放在原地备用。这一步骤的作用是令输入中只有叶子节点和运算符，相当于做了一次词法分析。

接下来，第二步按照运算优先级逐步分析输入内容，最终得到一个正则表达式语法分析树的根节点。

首先扫描由小括号领起的子式，递归应用第二步算法。

全部括号子式分析完后，我们就可以处理后缀运算符了，之后是串运算，再之后是联合运算。

完成全部步骤之后，输入序列中应当只剩下一个正则表达式语法树根节点，它就是我们想要的输出结果了。

## 4.2. 算法实现

算法整体由两个步骤构成，按照习俗，我们将其分别称为 `Scan` 和 `Parse`。在开始执行算法步骤前，我们需要先将输入从字符序列替换为单元序列。一个单元可以是一个字符或一个节点。

这个替换令尚未处理完毕的字符和已经部分处理完毕的语法树节点可以在同一个队列上共存，方便后续代码编写。

替换完毕后，我们在正式输入队列上先后执行 `Scan` 和 `Parse` 步骤。

执行完后，若一切正常，输入队列上应当仅剩下一个节点单元，我们把它提取出来用作返回值，就完成了正则表达式分析。

接下来的篇幅，我们将逐步展开讲解上文提及的各个算法步骤。

## 4.3. Scan 详解

`Scan` 算法从第一个单元开始处理，遇到方括号则调用 `ScanRange` 将方括号领起的字符类语法解析为范围节点，用节点单元替换原式字符单元子串。

若遇到反斜线，则尝试分析转义字符或转义字符类，将原字符单元替换为对应节点。

若遇到点，则替换为匹配任意字符的范围节点。

最后，如果当前字符不是运算符的话，将其替换为对应的字符节点单元。

## 4.4. ScanRange 详解

`ScanRange` 从输入序列的某个位置开始，首先检查开始字符是否为方括号。然后检查并剔除用于表示消极匹配的插入符号。

接下来，`ScanRange` 算法逐个迭代方括号内的字符，这里我们手工编写了一个拥有四个状态的小型状态机。

状态机的初始状态为1,每次循环应当处理当前字符并跳转状态。每个被处理过的字符会被移出输入队列，所以无需移动游标。

当前状态不大于零时离开循环，若此时状态为零，则表示分析成功，且原式已经从输入队列被完整删除。此时我们只要将分析过程中使用的缓冲节点插入游标位置即可。

### 4.4.1. 状态1详解

在每次循环中，若当前状态为1,即初始状态。

- 若当前字符为右方括号，则分析结束，将状态置为0。
- 若当前字符为反斜线，则进入2状态开始分析转义字符。
- 若当前字符为连字符，且左侧有可用作范围下界的字符则进入3状态尝试分析范围上界。
- 对于其它字符，我们将其计入字符集，并登记为范围下界。

### 4.4.2. 状态2详解

在第2状态，我们的主要任务是分析转义字符或转义字符类。分三种情况考虑：

第一种情况，转义序列表示单个字符且目标字符与序列中的字符不一致。我们通过查表获得目标字符，计入字符集后登记一个范围下界备用。

第二种情况，转义序列表示一个字符类，我们同样通过查表获得目标字符集，计入当前节点的字符集。但是不记录范围下界。

反斜线后出现任何其它字符被视为第三种情况，即转义序列表示单个字符，且目标字符与序列中的字符一致。我们将序列中的字符计入字符集，登记范围下界备用。

三种情况都分析完后，我们设置状态为1,回到初始状态。

### 4.4.3. 状态3详解

若程序进入3状态，意味着我们已经找到了一个范围的下界和连字符。接下来若我们能顺利找到一个字符用作上界就可以构成一个连续的字符范围，将范围内的字符全部登记到字符集中。

若当前字符为右方括号，连字符右侧没有出现我们期待的下界，不能构成范围。我们退而求其次，将连字符当作普通字符登记到字符集中，并结束分析。

若当前字符是一个反斜线，则进入4状态为范围上界分析转义字符。

对于其他字符，我们认为找到了范围上界。在登记字符范围之前，我们需要检查一下用户有没有把范围上下界放反，如果放反了，我们就需要反向遍历，以免溢出。

### 4.4.4. 状态4详解

最后是状态4。在4状态下，我们首先检查是否需要通过转义字符表替换当前字符。接下来我们检查字符范围的上下界是否倒置，并根据实际情况登记字符集。

要注意，每次成功分析了字符范围后，都要清除上界缓冲并回到初始状态。

## 4.5. Parse 详解

完成字符分析后，我们得到了一个仅包含运算符和叶子节点的单元序列。接下来我们来实现一个可以递归调用的 `Parse` 算法。

按照之前的规划， `Parse` 函数从一个指定的位置开始处理输入。第一个任务是递归处理所有由小括号领起的子式，顺便检查缺失或冗余右括号的问题。

我们从第一个单元开始检查，遇到右括号则判断递归深度。若当前函数是顶层调用，则意味着我们遇到了冗余的右括号，抛出异常。若当前函数不是顶层调用，则右括号表示当前子式到此为止，我们跳出括号检查循环，去处理当前子式中的其他运算符。

若检测到左括号，则递归调用 `Parse` 函数尝试处理一个子式。子式处理函数返回后，要检查一下右括号是否缺失。若缺失右括号也要抛出异常。

若子式处理任务顺利完成，意味着式子或者说当前子式中已经不缺失也不冗余右括号了。我们在接下来的全部任务中，都可以简单地将循环的退出条件设置为输入耗尽或遇到右括号。

接下来我们来逐一处理当前式子中的后缀运算符。原则很简单，逐一检查输入单元，遇到后缀运算符时，尝试将运算符前面的节点单元连同运算符一起归纳成一个新的后缀运算节点单元。若运算符前面没有单元或者运算符前面的单元不是节点，则报告一个解析错误。

后缀运算符处理完毕后，我们来处理串运算符。处理规则是这样的，从左向右扫描，若当前单元和上一个单元都是节点，且都在当前子式的范围内。则我们将他俩归纳成一个串运算节点单元，替换到输入序列的对应位置上。

最后我们来处理联合运算符。规则也很简单，从左向右扫描，找到联合运算符后检查运算符左右的单元是否存在，是否属于当前子式，是否均为节点。若条件都满足，则归纳，替换。

# 5. 总结

至此，我们已经完成了正则表达式解析组件的实现。下期视频我们来一起学习有穷状态机和状态跳转图的设计与实现。

各位小伙伴如果有什么问题，欢迎在评论区留言讨论。祝大家生活愉快，我们下期视频再见～